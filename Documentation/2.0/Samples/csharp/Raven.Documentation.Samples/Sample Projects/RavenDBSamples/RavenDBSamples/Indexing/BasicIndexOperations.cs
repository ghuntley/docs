using System;
using Raven.Abstractions.Indexing;
using Raven.Client;
using Raven.Client.Indexes;
using Raven.Client.Linq;
using RavenDBSamples.BaseForSamples;
using System.Linq;

namespace RavenDBSamples.Indexing
{
	public class BasicIndexOperations : SampleBase
	{
		public void CheckForStaleResults()
		{
			using (var session = DocumentStore.OpenSession())
			{
				RavenQueryStatistics stats;
				var results = session.Query<BlogPost>()
				                     .Statistics(out stats)
				                     .Where(x => x.Comments.Length > 10)
				                     .ToList();
				if (stats.IsStale)
				{
					// Results are known to be stale
				}
			}
		}

		public void WaitForNonStaleResults()
		{
			using (var session = DocumentStore.OpenSession())
			{
				RavenQueryStatistics stats;
				var results = session.Query<BlogPost>()
					.Statistics(out stats)
					.Where(x => x.Comments.Length > 10)
					.Customize(x => x.WaitForNonStaleResults(TimeSpan.FromSeconds(5)))
					.ToList();
			}
		}

		public void WaitForNonStaleResultsWithCutOff()
		{
			using (var session = DocumentStore.OpenSession())
			{
				RavenQueryStatistics stats;
				var results = session.Query<BlogPost>()
					.Statistics(out stats)
					.Where(x => x.Comments.Length > 10)
					.Customize(x => x.WaitForNonStaleResultsAsOf(new DateTime(2011, 5, 1, 10, 0, 0, 0))) // Waits for results for specific time
					.Customize(x => x.WaitForNonStaleResultsAsOfNow()) // waits for non stale results for now
					.Customize(x => x.WaitForNonStaleResultsAsOfLastWrite()) // waits for non stale results for last write
					.ToList();
			}
		}

		public void DefineIndex()
		{
			//Define Indexes from class
			IndexCreation.CreateIndexes(typeof(SingleMapIndex).Assembly, DocumentStore);

			//Directly define index
			DocumentStore.DatabaseCommands.PutIndex("BlogPosts/ByTitles",
			                                        new IndexDefinitionBuilder<BlogPost>
				                                        {
					                                        Map = posts => from post in posts
					                                                       select new {post.Title}
				                                        });
		}

		public void DefineMapReduceIndex()
		{
			//Define indexes from class
			IndexCreation.CreateIndexes(typeof(BlogPosts_PostsCountByTag).Assembly, DocumentStore);

			//Directly define index
			DocumentStore.DatabaseCommands
			             .PutIndex("BlogPosts/PostsCountByTag",
			                       new IndexDefinitionBuilder<BlogPost, BlogTagPostsCount>
				                       {
					                       // The Map function: for each tag of each post, create a new BlogTagPostsCount
					                       // object with the name of a tag and a count of one.
					                       Map = posts => from post in posts
					                                      from tag in post.Tags
					                                      select new
						                                      {
							                                      Tag = tag,
							                                      Count = 1
						                                      },

					                       // The Reduce function: group all the BlogTagPostsCount objects we got back
					                       // from the Map function, use the Tag name as the key, and sum up all the
					                       // counts. Since the Map function gives each tag a Count of 1, when the Reduce
					                       // function returns we are going to have the correct Count of posts filed under
					                       // each tag.
					                       Reduce = results => from result in results
					                                           group result by result.Tag
					                                           into g
					                                           select new
						                                           {
							                                           Tag = g.Key,
							                                           Count = g.Sum(x => x.Count)
						                                           }
				                       });
		}

		public class BlogTagPostsCount
		{
			public string Tag { get; set; }
			public int Count { get; set; }
		}
	}

	public class BlogPosts_PostsCountByTag : AbstractIndexCreationTask<BlogPost, BlogPosts_PostsCountByTag.ReduceResult>
	{
		public class ReduceResult
		{
			public string Tag { get; set; }
			public int Count { get; set; }
		}

		// The index name generated by this is going to be BlogPosts/PostsCountByTag
		public BlogPosts_PostsCountByTag()
		{
			Map = posts => from post in posts
						   from tag in post.Tags
						   select new
						   {
							   Tag = tag,
							   Count = 1
						   };

			Reduce = results => from result in results
								group result by result.Tag
									into g
									select new
									{
										Tag = g.Key,
										Count = g.Sum(x => x.Count)
									};
		}
	}

	public class SingleMapIndex : AbstractIndexCreationTask<BlogPost>
	{
		public SingleMapIndex()
		{
			Map = posts => from post in posts
			               select new {post.Title};
		}
	}

	public class MultiMapIndex : AbstractMultiMapIndexCreationTask<MultiMapIndex.Result>
	{
		public class Result
		{
			public object[] Content { get; set; }
		}

		public override string IndexName
		{
			get { return "SearchableItems/ByContent"; }
		}

		public MultiMapIndex()
		{
			AddMap<BlogPost>(items => from x in items
			                          select
				                          new Result {Content = new object[] {x.Author, x.Content, x.Content, x.Title, x.Tags}});

			AddMap<Order>(items => from x in items
			                       select new Result {Content = new object[] {x.Title}});

			AddMap<Company>(items => from x in items
			                      select new Result {Content = new object[] {x.Name, x.Type}});

			Index(x => x.Content, FieldIndexing.Analyzed);
		}
	}
}
